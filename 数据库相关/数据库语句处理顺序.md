内容来自 [https://www.nowcoder.com](https://www.nowcoder.com/questionTerminal/8065519d109c467184681aafa5a798f3)

SQL 不同于与其他编程语言的最明显特征是处理代码的顺序。在大数编程语言中，代码按编码顺序被处理，但是在SQL语言中，第一个被处理的子句是 **FROM** 子句，尽管 **SELECT** 语句第一个出现，但是几乎总是最后被处理。
       
每个步骤都会产生一个虚拟表，该虚拟表被用作下一个步骤的输入。这些虚拟表对调用者（客户端应用程序或者外部查询）不可用。只是最后一步生成的表才会返回给调用者。如果没有在查询中指定某一子句，将跳过相应的步骤。下面是对应用于SQL server 2000和SQL Server 2005的各个逻辑步骤的简单描述。

```shell
 (8) SELECT (9) DISTINCT (11) <Top Num> <select list>
  
 (1) FROM [left_table]
  
 (3) <join_type> JOIN <right_table>
  
 (2) ON <join_condition>
  
 (4) WHERE <where_condition>
  
 (5) GROUP BY <group_by_list>
  
 (6) WITH <CUBE | RollUP>
  
 (7) HAVING <having_condition>
  
 (10) ORDER BY <order_by_list>
```

**逻辑查询处理阶段简介**

1. ​    **FROM：**对FROM子句中的前两个表执行笛卡尔积（Cartesian    product)(交叉联接），生成虚拟表VT1  

2. ​    **ON：**对VT1应用ON筛选器。只有那些使<join_condition>为真的行才被插入VT2。  

3. ​    **OUTER(JOIN)：**如 果指定了OUTER JOIN（相对于CROSS JOIN 或(INNER    JOIN),保留表（preserved    table：左外部联接把左表标记为保留表，右外部联接把右表标记为保留表，完全外部联接把两个表都标记为保留表）中未找到匹配的行将作为外部行添加到    VT2,生成VT3.如果FROM子句包含两个以上的表，则对上一个联接生成的结果表和下一个表重复执行步骤1到步骤3，直到处理完所有的表为止。  

4. ​    **WHERE：**对VT3应用WHERE筛选器。只有使<where_condition>为true的行才被插入VT4.  

5. ​    **GROUP BY：**按GROUP BY子句中的列列表对VT4中的行分组，生成VT5.  

6. ​    **CUBE|ROLLUP：**把超组(Suppergroups)插入VT5,生成VT6.  

7. ​    **HAVING：**对VT6应用HAVING筛选器。只有使<having_condition>为true的组才会被插入VT7.  

8. ​    **SELECT：**处理SELECT列表，产生VT8.  

9. ​    **DISTINCT：**将重复的行从VT8中移除，产生VT9.  

10. ​    **ORDER BY：**将VT9中的行按ORDER BY 子句中的列列表排序，生成游标（VC10).  

11. ​    **TOP：**从VC10的开始处选择指定数量或比例的行，生成表VT11,并返回调用者。

   注：步骤10，按ORDER  BY子句中的列列表排序上步返回的行，返回游标VC10.这一步是第一步也是唯一一步可以使用SELECT列表中的列别名的步骤。这一步不同于其它步骤的  是，它不返回有效的表，而是返回一个游标。SQL是基于集合理论的。集合不会预先对它的行排序，它只是成员的逻辑集合，成员的顺序无关紧要。对表进行排序  的查询可以返回一个对象，包含按特定物理顺序组织的行。ANSI把这种对象称为游标。理解这一步是正确理解SQL的基础。

## 一个例子

```sql
select foo,count(foo) from pokes where foo > 10 group by foo having count (*) > 5 order by foo 
```

上面语句的执行顺序为:

```shell
FROM->WHERE->GROUP BY->HAVING->SELECT->ORDER BY
```

